{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Interactive Visualisation Framework 2","text":"<p>Welcome to the ivf2 documentation. ivf2 is a modern C++ graphics and visualization library built on top of OpenGL.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Modern, object-oriented C++ design</li> <li>Powerful scene graph management</li> <li>Extensive set of 3D primitives</li> <li>Flexible material system</li> <li>Dynamic lighting system</li> <li>Animation capabilities</li> <li>Post-processing effects</li> <li>ImGui-based user interface</li> <li>Model loading via Assimp</li> <li>Shadow mapping</li> <li>And more!</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Visit the Getting Started section to begin using ivf2.</p>"},{"location":"#examples","title":"Examples","text":"<p>Check out the Examples section to see ivf2 in action.</p>"},{"location":"animation/basic_animation/","title":"Basic Animation","text":"<p>This guide introduces the animation system in ivf2.</p>"},{"location":"animation/basic_animation/#overview","title":"Overview","text":"<p>ivf2 provides several ways to animate objects in your scene. The simplest form is direct manipulation of transform properties (position, rotation, scale) over time.</p>"},{"location":"animation/basic_animation/#animation-basics","title":"Animation Basics","text":""},{"location":"animation/basic_animation/#using-the-update-loop","title":"Using the Update Loop","text":"<p>The simplest way to animate objects is to modify properties in the <code>onUpdate()</code> method:</p> <pre><code>class MyWindow : public ivfui::GLFWSceneWindow {\nprivate:\n    ivf::CubePtr m_cube;\n\npublic:\n    // ... constructor and other methods ...\n\n    virtual void onUpdate() override {\n        m_cube-&gt;setRotAxis(glm::vec3(1.0, 1.0, 1.0));\n        m_cube-&gt;setRotAngle(20.0 * elapsedTime());\n    }\n};\n</code></pre>"},{"location":"animation/basic_animation/#time-based-animation","title":"Time-Based Animation","text":"<p>Always use time-based animation instead of frame-based animation to ensure consistent speed across different systems:</p> <pre><code>// Bad - frame-based animation\nm_angle += 1.0;\nobject-&gt;setRotAngle(m_angle);\n\n// Good - time-based animation\nobject-&gt;setRotAngle(20.0 * elapsedTime());\n</code></pre>"},{"location":"animation/basic_animation/#animation-types","title":"Animation Types","text":"<p>ivf2 offers several built-in animation types:</p> <ol> <li>Direct manipulation - Updating properties each frame</li> <li>SplineAnimation - Animation along a spline path</li> <li>KeyframeAnimation - Animation between key poses</li> <li>Procedural animation - Using mathematical functions</li> </ol>"},{"location":"core/nodes/","title":"Node System","text":"<p>The ivf2 node system is the foundation of the scene graph hierarchy in the library.</p>"},{"location":"core/nodes/#overview","title":"Overview","text":"<p>The node system in ivf2 follows a classic scene graph architecture, where each node can have child nodes and a single parent node. This hierarchical structure allows for complex scenes to be built from simple components.</p>"},{"location":"core/nodes/#node-base-class","title":"Node Base Class","text":"<p>The <code>Node</code> class is the base class for all scene graph elements in ivf2. It provides common functionality such as:</p> <ul> <li>Position, rotation, and scale transformations</li> <li>Parent-child relationships</li> <li>Rendering capabilities</li> <li>Material assignment</li> <li>Visibility control</li> </ul>"},{"location":"core/nodes/#key-node-types","title":"Key Node Types","text":""},{"location":"core/nodes/#transformnode","title":"TransformNode","text":"<p>The <code>TransformNode</code> class allows for coordinate transformations that affect all of its children.</p> <pre><code>auto transform = ivf::Transform::create();\ntransform-&gt;setPos(glm::vec3(1.0, 0.0, 0.0));\ntransform-&gt;setRotAxis(glm::vec3(0.0, 1.0, 0.0));\ntransform-&gt;setRotAngle(45.0);\n</code></pre>"},{"location":"core/nodes/#compositenode","title":"CompositeNode","text":"<p>The <code>CompositeNode</code> class is a container for multiple child nodes, implementing the Composite pattern.</p> <pre><code>auto composite = ivf::CompositeNode::create();\ncomposite-&gt;add(node1);\ncomposite-&gt;add(node2);\n</code></pre>"},{"location":"core/nodes/#other-node-types","title":"Other Node Types","text":"<ul> <li><code>Geometry</code> - Base class for all geometric entities</li> <li><code>Light</code> - Base class for light sources</li> <li><code>Camera</code> - Defines the viewpoint and projection</li> </ul>"},{"location":"core/nodes/#working-with-nodes","title":"Working with Nodes","text":""},{"location":"core/nodes/#creating-nodes","title":"Creating Nodes","text":"<p>Most node classes in ivf2 follow the factory pattern with static <code>create()</code> methods:</p> <pre><code>auto cube = ivf::Cube::create();\nauto sphere = ivf::Sphere::create(1.0f); // radius\n</code></pre>"},{"location":"core/nodes/#node-hierarchy","title":"Node Hierarchy","text":"<p>Building a scene graph hierarchy:</p> <pre><code>auto scene = ivf::CompositeNode::create();\nauto transform = ivf::Transform::create();\nauto cube = ivf::Cube::create();\n\ntransform-&gt;add(cube);\nscene-&gt;add(transform);\n</code></pre>"},{"location":"examples/animation_examples/","title":"Animation Examples","text":"<p>This section explores the animation examples provided with ivf2.</p>"},{"location":"examples/animation_examples/#animation1-example","title":"animation1 Example","text":"<p>The <code>animation1</code> example demonstrates simple animations using direct manipulation within the update loop.</p>"},{"location":"examples/animation_examples/#key-concepts-demonstrated","title":"Key Concepts Demonstrated","text":"<ul> <li>Basic rotation animation</li> <li>Time-based animation</li> <li>Multiple animated objects</li> </ul>"},{"location":"examples/animation_examples/#code-walkthrough","title":"Code Walkthrough","text":"<pre><code>virtual void onUpdate()\n{\n    m_cube-&gt;setRotAxis(glm::vec3(1.0, 1.0, 1.0));\n    m_cube-&gt;setRotAngle(20.0 * elapsedTime());\n\n    m_sphereXfm-&gt;setRotAxis(glm::vec3(0.0, 1.0, 0.0));\n    m_sphereXfm-&gt;setRotAngle(20.0 * elapsedTime());\n}\n</code></pre> <p>The above code rotates a cube around a diagonal axis and a sphere around the Y axis. The rotation speed is controlled by the elapsed time.</p>"},{"location":"examples/animation_examples/#animation2-example","title":"animation2 Example","text":"<p>The <code>animation2</code> example shows a more complex Lissajous animation with an interactive UI.</p>"},{"location":"examples/animation_examples/#key-concepts-demonstrated_1","title":"Key Concepts Demonstrated","text":"<ul> <li>Lissajous curve animation</li> <li>LineTrace for path visualization</li> <li>Interactive parameter control with ImGui</li> <li>Dynamic parameter updates</li> </ul>"},{"location":"examples/animation_examples/#lissajous-class","title":"Lissajous Class","text":"<pre><code>class Lissajous {\nprivate:\n    float m_a, m_b, m_c, m_d, m_e, m_f, m_g, m_h, m_i;\n\npublic:\n    // ... constructor and methods ...\n\n    glm::vec3 operator()(float t) {\n        return glm::vec3(m_a * sin(m_b * t + m_d), m_c * sin(m_e * t + m_f), m_g * sin(m_h * t + m_i));\n    }\n};\n</code></pre>"},{"location":"examples/animation_examples/#update-loop","title":"Update Loop","text":"<pre><code>virtual void onUpdate() override\n{\n    // Check if UI parameters were changed\n    if (m_lissajouWindow-&gt;is_dirty())\n    {\n        float a, b, c, d, e, f, g, h, i;\n        m_lissajouWindow-&gt;get_params(a, b, c, d, e, f, g, h, i);\n        m_lissajous.setParameters(a, b, c, d, e, f, g, h, i);\n        m_speed = m_lissajouWindow-&gt;speed();\n        m_trace-&gt;setSize(m_lissajouWindow-&gt;size());\n        m_trace-&gt;reset();\n    }\n\n    // Update sphere position\n    auto pos = m_lissajous(elapsedTime() * m_speed);\n    m_sphere-&gt;setPos(pos);\n    m_trace-&gt;add(pos);\n    m_trace-&gt;refresh();\n}\n</code></pre>"},{"location":"getting_started/basic_concepts/","title":"Basic concepts","text":"<p>The Ivf2 library is designed to be easy to use and integrate into your projects. This document provides an overview of the basic concepts and components of the library. It is recommended to read this document before diving into the examples and tutorials.</p>"},{"location":"getting_started/basic_concepts/#architectural-overview","title":"Architectural Overview","text":"<p>The Ivf2 library is built around a modular architecture that allows for easy extension and customization. One of the key concepts is to abstract a lot of the OpenGL functionality into higher-level constructs, making it easier to work with. The library is designed to be flexible and extensible, allowing you to create complex applications with minimal effort.</p> <p>Ivf2 is not designed to be a game engine, but rather a graphics library that provides the necessary parts to implement interactive graphical applications. It is built on top of OpenGL and provides a higher-level interfaces for rendering, resource management, and window management.</p> <p>The library is also designed in a way that allows you to use OpenGL directly if you need to. This means that you can use Ivf2 to manage your resources and windowing, while still having the flexibility to use OpenGL directly for rendering if needed.</p> <p>The development of the library has also been a personal project for me to learn more about OpenGL and graphics programming. As such, the library is designed to be easy to use and understand, with a focus on providing a good developer experience. In this process I have also tried design it with modern C++ in mind, using features like smart pointers and RAII to manage resources and avoid memory leaks.</p> <p>Ivf2 is also designed to be cross-platform and works on Windows, macOS, and Linux. It uses CMake as its build system, making it easy to integrate into your projects.</p>"},{"location":"getting_started/basic_concepts/#scene-graph-system","title":"Scene Graph System","text":"<p>Ivf2 uses a scene graph system to manage the objects in your scene. The scene graph is a hierarchical structure that represents the objects in your scene and their relationships to each other. It allows you to organize your objects in a way that makes it easy to manage and render them.</p> <p>The scene graph system in Ivf2 is built around the concept of nodes, which represent the objects in your scene. All nodes in Ivf2 derives from the <code>Node</code> and <code>TransformNode</code> classes, which provide a common interface for all nodes such as orientation, assigning an id, setting a parent, setting visibility and other properties such as material and texture. Rendering of the node is implemented by derived classed in the <code>doPreDraw()</code>, <code>doDraw()</code> , and <code>doPostDraw()</code> methods. These methods are called when calling the <code>draw()</code> method on the node, allowing you to implement custom rendering logic for your nodes. The Node class should not be used directly, but rather as a base class for your own nodes. Position, rotation, and scaling is handled by the derived <code>Node</code> class <code>TransformNode</code> class. The <code>TransformNode</code> class provides methods for setting and getting the position, rotation, and scaling of the node. It also provides methods for converting between world and local coordinates.</p> <p>There are 4 types of nodes in the Ivf2 scene graph system:</p> <ul> <li><code>MeshNode</code>: Represents a mesh in the scene. It is used to render 3D models and can be used to create complex scenes with multiple meshes.</li> <li><code>CompositeNode</code> / <code>Transform</code>: Represents a group of nodes in the scene. It is used to create complex scenes with multiple nodes and can be used to create hierarchical structures.</li> <li><code>InstanceNode</code>: Represents an instance of a mesh in the scene. It is used to create multiple instances of a mesh with different transformations and properties.</li> <li><code>TextNode</code>: Represents a text in the scene. It is used to render text in the scene and can be used to create complex scenes with multiple text nodes.</li> </ul>"},{"location":"getting_started/basic_concepts/#rendering-pipeline","title":"Rendering Pipeline","text":"<p>Ivf2 has no built-in rendering pipeline, but it provides a set of classes and functions that can be used to create your own rendering pipeline. The library provides a set of classes for managing shaders, textures, and materials, as well as a set of functions for rendering objects in the scene.</p> <p>Rendering with Ivf2 is usually done in to steps. In the first step, the setup stage, consists of initialising the shaders, textures, and other resources needed for rendering. This is usually done in the <code>onSetup()</code> method of the <code>GLFWWindow</code> class. We will go through the steps of the setup stage in the following sections.</p> <p>First we initialise a basic shader. Ivf2 provides a basic shader that implements most of the funcitonality required for rendering the Ivf2 nodes. The code below shows how this is done.</p> <pre><code>int onSetup()\n{\n    // Load basic shaders\n\n    auto shaderMgr = ShaderManager::instance();\n    shaderMgr-&gt;loadBasicShader();\n\n    // Check for shader compilation errors\n\n    if (shaderMgr-&gt;compileLinkErrors())\n    {\n        cout &lt;&lt; \"Couldn't compile shaders, exiting...\" &lt;&lt; endl;\n        return -1;\n    }\n</code></pre> <p>Note</p> <p>In all the examples in this chapter we have omitted the ivf namespace. The Ivf2 library is designed to be used with the <code>ivf</code> namespace, so all classes and functions in the library are prefixed with <code>ivf::</code>. In the examples we will use the <code>using namespace ivf;</code> directive to avoid having to prefix all classes and functions with <code>ivf::</code>. This is not recommended in production code, but it makes the examples easier to read.</p> <p>The <code>ShaderManager</code> singleton class is used to manage the shaders in the library. It provides methods for loading and compiling shaders, as well as for checking for compilation errors. The <code>ShaderManager</code> class is a singleton, meaning that there is only one instance of it in the application. The <code>instance()</code> method of this class will always return the same instance of the class. The <code>loadBasicShader()</code> method loads the basic shader from the Ivf2 library. The <code>compileLinkErrors()</code> method checks for compilation errors in the shaders. If there are any errors, it will print them to the console and return true. If there are no errors, it will return false.</p> <p>In the next step we initialise scene lighting by using the <code>LightManager</code> class. The <code>LightManager</code> class is used to manage the lights in the scene. It provides methods for adding and removing lights, as well as for updating the lights in the scene. The <code>LightManager</code> class is also a singleton accessed by the <code>instance()</code> method. The code below shows how to add a light to the scene.</p> <pre><code>    // Setup lighting\n\n    auto lightMgr = LightManager::instance();\n\n    auto pointLight1 = lightMgr-&gt;addPointLight();\n    pointLight1-&gt;setEnabled(true);\n    pointLight1-&gt;setPosition(glm::vec3(5.0, 5.0, 15.0));\n\n    lightMgr-&gt;apply();\n</code></pre> <p>The <code>addPointLight()</code> method adds a point light to the scene. The <code>setEnabled()</code> method enables or disables the light. The <code>setPosition()</code> method sets the position of the light in the scene. The <code>apply()</code> method updates the lights in the shader. The <code>LightManager</code> class also provides methods for adding and removing other types of lights, such as directional lights and spotlights.</p> <p>Next, we setup out scene nodes for rendering. In out example we are using a <code>CompositeNode</code> to represent the scene. The <code>CompositeNode</code> class is used to create a group of nodes in the scene to be rendered together. It can also be used to create complex scenes with multiple nodes and to create hierarchical structures.  The code below shows how to create a <code>CompositeNode</code> and add a <code>Cube</code> node to it.</p> <p>Note</p> <p>Variables in the examples prefixed with <code>m_</code> are member variables of the <code>GLFWWindow</code> derived class. </p> <pre><code>    // Setup scene\n\n    m_scene = CompositeNode::create();\n\n    auto node = Cube::create();\n\n    auto material = Material::create();\n    material-&gt;setDiffuseColor(glm::vec4(1.0, 0.0, 0.0, 1.0));\n    material-&gt;setAmbientColor(glm::vec4(0.1, 0.1, 0.1, 1.0));\n\n    node-&gt;setPos(glm::vec3(0.0, 0.0, 0.0));\n    node-&gt;setMaterial(material);\n\n    m_scene-&gt;add(node);\n</code></pre> <p>In the code above we create a <code>Cube</code> node and set its position and material. The <code>Cube</code> class is a derived class of the <code>MeshNode</code> class, which is used to render 3D models in the scene. The <code>Material</code> class is used to set the material properties of the node, such as the diffuse and ambient colors. The <code>setPos()</code> method sets the position of the node in the scene. </p> <p>Finally, we setup our camera for rendering. The camera is used to view the scene and is usually implemented as a separate class. The code below shows how to create a camera and set its position and orientation.</p> <pre><code>    // Setup camera\n\n    m_camera = Camera::create();\n    m_camera-&gt;setPosition(glm::vec3(-3.0, 3.0, 3.0));\n    m_camera-&gt;setTarget(glm::vec3(0.0, 0.0, 0.0));\n    m_camera-&gt;setUp(glm::vec3(0.0, 1.0, 0.0));\n    m_camera-&gt;setPerspective(45.0, 0.1f, 100.0f);\n    m_camera-&gt;setViewport(this-&gt;width(), this-&gt;height());\n</code></pre> <p>Finally we are ready to render our scene. The rendering is done in the <code>onDraw()</code> method of the <code>GLFWWindow</code> class. The code below shows how to render the scene.</p> <pre><code>void onDraw()\n{\n    glClearColor(0.07f, 0.13f, 0.17f, 1.0f);\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    m_scene-&gt;draw();\n}\n</code></pre> <p>This was a high level overview of the rendering pipeline in Ivf2. The idea is to provide easy to use classes and functions that can be used to create a rendering pipeline that fits your needs, without having to worry about the low level details of OpenGL. </p>"},{"location":"getting_started/basic_concepts/#window-and-application-management","title":"Window and Application Management","text":"<p>The Ivf2 library provides a set of classes based on GLFW for managing windows and applications. The <code>GLFWWindow</code> class is the main class for managing windows and provides methods for creating, destroying, and managing windows. It also provides methods for handling input events, such as keyboard and mouse events.</p> <p>To implement your own application, you first need to implement a class that derives from the <code>GLFWWindow</code> class. In this class you will need to implement/override the <code>onSetup()</code>, <code>onDraw()</code>, and <code>onKey()</code> virtual methods to handle the setup, rendering, and input events for your application. The <code>onSetup()</code> method is called once when the window is created and is used to setup the scene and resources needed for rendering. You can expect to have a rendering context available when this method is called. The <code>onDraw()</code> method is called when the window needs to be redrawn and is used to render the scene. The <code>onKey()</code> method is called when a key is pressed or released and is used to handle input events. The following shows a simple example of a class that derives from the <code>GLFWWindow</code> class.</p> <pre><code>#include &lt;ivf/gl.h&gt;\n#include &lt;ivf/nodes.h&gt;\n#include &lt;ivfui/ui.h&gt;\n\nusing namespace ivf;\nusing namespace ivfui;\nusing namespace std;\n\nclass ExampleWindow : public GLFWWindow {\nprivate:\n    CompositeNodePtr m_scene;\n    CameraPtr m_camera;\n\npublic:\n    ExampleWindow(int width, int height, std::string title) : GLFWWindow(width, height, title)\n    {}\n\n    static std::shared_ptr&lt;ExampleWindow&gt; create(int width, int height, std::string title)\n    {\n        return std::make_shared&lt;ExampleWindow&gt;(width, height, title);\n    }\n\n    int onSetup()\n    {\n        // Load basic shaders\n\n        auto shaderMgr = ShaderManager::instance();\n        shaderMgr-&gt;loadBasicShader();\n\n        // Check for shader compilation errors\n\n        if (shaderMgr-&gt;compileLinkErrors())\n        {\n            cout &lt;&lt; \"Couldn't compile shaders, exiting...\" &lt;&lt; endl;\n            return -1;\n        }\n\n        // Setup lighting\n\n        auto lightMgr = LightManager::instance();\n\n        auto pointLight1 = lightMgr-&gt;addPointLight();\n        pointLight1-&gt;setEnabled(true);\n        pointLight1-&gt;setPosition(glm::vec3(5.0, 5.0, 15.0));\n\n        lightMgr-&gt;apply();\n\n        // Setup scene\n\n        m_scene = CompositeNode::create();\n\n        auto node = Cube::create();\n\n        auto material = Material::create();\n        material-&gt;setDiffuseColor(glm::vec4(1.0, 0.0, 0.0, 1.0));\n        material-&gt;setAmbientColor(glm::vec4(0.1, 0.1, 0.1, 1.0));\n\n        node-&gt;setPos(glm::vec3(0.0, 0.0, 0.0));\n        node-&gt;setMaterial(material);\n\n        m_scene-&gt;add(node);\n\n        // Setup camera\n\n        m_camera = Camera::create();\n        m_camera-&gt;setPosition(glm::vec3(-3.0, 3.0, 3.0));\n        m_camera-&gt;setTarget(glm::vec3(0.0, 0.0, 0.0));\n        m_camera-&gt;setUp(glm::vec3(0.0, 1.0, 0.0));\n        m_camera-&gt;setPerspective(45.0, 0.1f, 100.0f);\n\n        m_camera-&gt;setViewport(this-&gt;width(), this-&gt;height());\n\n        return 0;\n    }\n\n    void onDraw()\n    {\n        glClearColor(0.07f, 0.13f, 0.17f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        m_scene-&gt;draw();\n    }\n\n    void onResize(int width, int height)\n    {\n        m_camera-&gt;setViewport(width, height);\n    }\n};\n</code></pre> <p>The event loop and window management is handled by the <code>GLFWApplication</code> class. This class is a simple wrapper around the GLFW library and provides a simple interface for creating and managing windows. The event loop is implemented in the <code>loop()</code> method of the <code>GLFWApplication</code> class. The <code>run()</code> method creates a window and enters the event loop, handling input events and rendering the scene. It is also in the <code>GLFWApplication</code> class that you setup what OpenGL version and attributes you want to use. The code below shows how to create a window and enter the event loop.</p> <pre><code>typedef std::shared_ptr&lt;ExampleWindow&gt; ExampleWindowPtr;\n\nint main()\n{\n    // Create a FLFW application instance\n\n    auto app = GLFWApplication::create();\n\n    // Set GLFW hints for OpenGL version and profile\n\n    app-&gt;hint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    app-&gt;hint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    app-&gt;hint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    app-&gt;hint(GLFW_SAMPLES, 4);\n\n    // Create our example window\n\n    auto window = ExampleWindow::create(800, 800, \"Hello, ivf2\");\n    window-&gt;maximize();\n\n    // Add window to application instance\n\n    app-&gt;addWindow(window);\n\n    // Enter application loop. This will block until the application is closed.\n\n    return app-&gt;loop();\n}\n</code></pre> <p>The <code>GLFWApplication</code> class and <code>GLFWWindow</code> class are implemented in the <code>imgui</code> library. This library also contains the user interface classes for implementing ImGui windows and menus. </p>"},{"location":"getting_started/basic_concepts/#resource-management","title":"Resource Management","text":"<p>Ivf2 doesn't implement a resource management system, but it provides a set of classes and functions that can be used to manage resources in your application. The library provides a set of classes for managing shaders, textures, and materials, as well as a set of functions for loading and saving resources.</p> <p>Shared are used extensively in the library to manage resources. The <code>std::shared_ptr</code> class is used to manage the lifetime of objects in the library. This means that you don't have to worry about memory management and can focus on implementing your application logic. The <code>std::shared_ptr</code> class is a smart pointer that manages the lifetime of an object and automatically deletes it when it is no longer needed. This means that you don't have to worry about memory leaks and can focus on implementing your application logic.</p> <p>The main principle is that you use the <code>onSetup()</code> method to load and setup your resources, and the <code>onDraw()</code> method to render your scene. The <code>onSetup()</code> method is called once when the window is created and is used to setup the scene and resources needed for rendering. The main window class will be responsible for maintaining the scene with its attached resources. </p> <p>Using a <code>CompositeNode</code> as the main scene node is a good way to manage your resources. Materials and textures can be creates and assigned to the nodes in the scene. As they are shared pointers, they will be automatically deleted when they are no longer needed. This means that you don't have to worry about memory management and can focus on implementing your application logic. When the scene is destroyed, all the resources will be automatically deleted. </p>"},{"location":"getting_started/basic_concepts/#core-design-patterns","title":"Core Design Patterns","text":"<p>As Ivf2 uses shared pointers extensively, it is important to understand how they work and how to use them correctly. The library uses the RAII (Resource Acquisition Is Initialization) pattern to manage resources. This means that resources are acquired and released in the constructor and destructor of the class. This ensures that resources are always released when they are no longer needed and avoids memory leaks.</p> <p>To make it easier to use shared pointers, all the classes in the library have a special <code>create()</code> method that returns a shared pointer to the class. This method is used to create instances of the class and ensures that the class is always created with a shared pointer. The <code>create()</code> method is a static method that returns a shared pointer to the class. You don't have to call <code>std::make_shared()</code> yourself, as the <code>create()</code> method will do that for you. This makes it easier to create instances of the class and avoids memory leaks. Most of the examples in this documentation will use the <code>create()</code> method to create instances of the class. In the following example we create a <code>Cube</code> node and set its position and material using the <code>create()</code> method.</p> <pre><code>auto node = Cube::create();\nauto material = Material::create();\n\nmaterial-&gt;setDiffuseColor(glm::vec4(1.0, 0.0, 0.0, 1.0));\nmaterial-&gt;setAmbientColor(glm::vec4(0.1, 0.1, 0.1, 1.0));\nnode-&gt;setPos(glm::vec3(0.0, 0.0, 0.0));\nnode-&gt;setMaterial(material);\n</code></pre> <p>All classes in the library also provide typedefs for the shared pointers to the class. This makes it easier to use shared pointers and avoids having to type <code>std::shared_ptr</code> all the time. The typedefs are usually named <code>ClassNamePtr</code>, where <code>ClassName</code> is the name of the class. For example, the <code>Cube</code> class has a typedef named <code>CubePtr</code>, which is a shared pointer to the <code>Cube</code> class. You can use this typedef to create shared pointers to the <code>Cube</code> class without having to type <code>std::shared_ptr&lt;Cube&gt;</code> all the time.</p> <pre><code>typedef std::shared_ptr&lt;Cube&gt; CubePtr;\n</code></pre> <p>For example a class attribute for a <code>CompositeNode</code> can be declared as follows:</p> <pre><code>CompositeNodePtr m_scene;\n</code></pre> <p>When creating references to classes in the library in most cases you can also use the <code>auto</code> keyword to automatically deduce the type of the variable. This makes it easier to write code and avoids having to type the full type of the variable. For example, you can create a shared pointer to a <code>Cube</code> class as follows:</p> <pre><code>auto node = Cube::create();\n</code></pre>"},{"location":"getting_started/installation/","title":"Installation","text":"<p>This guide will help you install and set up the ivf2 library for your project.</p>"},{"location":"getting_started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>CMake 3.12+</li> <li>C++17 compatible compiler</li> <li>OpenGL 3.3+</li> <li>GLFW3</li> <li>GLEW</li> <li>ImGui</li> <li>Assimp (for model loading)</li> <li>Freetype (for text rendering)</li> </ul>"},{"location":"getting_started/installation/#dependencies","title":"Dependencies","text":"<p>The following dependencies are required to build ivf2:</p> <ul> <li>GLFW (window management)</li> <li>GLEW (OpenGL extension loading)</li> <li>GLM (mathematics)</li> <li>ImGui (user interface)</li> <li>Assimp (model loading)</li> <li>Freetype (font rendering)</li> <li>stb_image (image loading)</li> </ul>"},{"location":"getting_started/installation/#install-vcpkg","title":"Install vcpkg","text":"<p>Ivf2 uses vcpkg to manage its dependencies. Instruction on how to install vcpkg can be found here</p>"},{"location":"getting_started/installation/#clone-the-repository","title":"Clone the Repository","text":"<p>To get started, clone the ivf2 repository from GitHub:</p> <pre><code>git clone https://github.com/your-username/ivf2.git\ncd ivf2\n</code></pre>"},{"location":"getting_started/installation/#configuring-the-library","title":"Configuring the Library","text":"<p>To build the ivf2 library, follow these steps:</p> <p>In the ivf2 directory, run the following commands:</p> <pre><code>python build-ivf.py --configure --build-type=Debug --preset=default\n</code></pre> <p>This command will check for the vcpkg.cmake toolchain file and configure the build system accordingly. It will also build the library in Debug mode. You can change the <code>--build-type</code> to <code>Release</code> for a release build.</p> <pre><code>--- Setting up toolchain file...\n\nEnter the path to the toolchain file (default: c:/vcpkg/scripts/buildsystems/vcpkg.cmake):\n</code></pre> <p>Press Enter to use the default path or provide a custom path to the vcpkg toolchain file. This will set up the vcpkg toolchain file for the build process. Next, the required package dependencies will be installed. This may take some time depending on your internet connection and system performance.</p> <p>When the configuration is complete, you will see a message indicating that the dependencies have been successfully installed.</p> <pre><code>-- Configuring done (20.8s)\n-- Generating done (0.5s)\n-- Build files have been written to: E:/Users/Jonas/Development/ivf2/build-debug\n</code></pre>"},{"location":"getting_started/installation/#building-the-library","title":"Building the Library","text":"<p>After configuring the library, you can build it using the following command:</p> <pre><code>cmake --build build-debug --config Debug\n</code></pre> <p>or</p> <p><pre><code>cmake --build build-release --config Release\n</code></pre> This will compile the library and create the necessary binaries. The output will be located in the <code>build-debug</code> or <code>build-release</code> directory, depending on the build type you chose.</p> <p>When the build is complete, you will see a message indicating that the build was successful (MSBUILD).</p> <pre><code>  example_window_1.cpp\n  example_window_2.cpp\n  Generating Code...\n  ui1d.vcxproj -&gt; E:\\Users\\Jonas\\Development\\ivf2\\bin\\Debug\\ui1d.exe\n  Building Custom Rule E:/Users/Jonas/Development/ivf2/CMakeLists.txt\n</code></pre> <p>On Windows executables will be located in the <code>bin/Debug</code> or <code>bin/Release</code> directory, depending on the build type you chose. On Linux, the executables will be located in the <code>bin</code> directory. On macOS, the executables will be located in the <code>bin</code> directory as well.</p> <p>Libraries will be located in the <code>lib/Debug</code> or <code>lib/Release</code> directory on Windows and <code>lib</code> on Linux and mac. Header files will be in the <code>include</code> directory.</p>"},{"location":"getting_started/installation/#integrating-with-your-project","title":"Integrating with Your Project","text":"<p>To integrate ivf2 into your project, follow these steps:</p> <ol> <li>Include the ivf2 headers in your project.</li> <li>Link against the ivf2 library.</li> <li>Set up the appropriate include paths.</li> </ol>"},{"location":"getting_started/your_first_app/","title":"Your first app","text":"<p>The easiest way to create an application using the Ivf2 framework is to use the available template application that is available on GitHub. This template contains all the necessary files and folders to get started with your application. You can find the template application here.</p>"},{"location":"getting_started/your_first_app/#create-a-new-application","title":"Create a new application","text":"<p>First we clone the template application from GitHub. Open a terminal and run the following command:</p> <pre><code>git clone https://github.com/jonaslindemann/ivf2_app.git\n</code></pre> <p>This will create a new folder called <code>ivf2_app</code> in your current directory. You can rename this folder to whatever you like. For this example, we will keep the name <code>ivf2_app</code>.</p>"},{"location":"getting_started/your_first_app/#configure-and-build-the-application-windows","title":"Configure and build the application (Windows)","text":"<p>To configure the application you need to run CMake with the following options:</p> <pre><code>cmake --preset windows\n</code></pre> <p>To configure a debug build, use the following command:</p> <pre><code>cmake --preset windows-debug\n</code></pre> <p>To build a release version of the application, use the following command:</p> <pre><code>cmake --build --preset release\n</code></pre> <p>To build a debug version of the application, use the following command:</p> <pre><code>cmake --build --preset debug\n</code></pre> <p>There is also a windows batch file that can be used to build the application. To use it, run the following command:</p> <pre><code>build_windows.bat [debug|release] [ivf2_path]\n</code></pre> <p>Where <code>ivf2_path</code> is the path to the Ivf2 framework. If you want to use the default path, you can omit this argument. The default path is <code>..\\ivf2</code>. The <code>debug</code> or <code>release</code> argument specifies whether you want to build a debug or release version of the application. If you omit this argument, it will default to <code>release</code>. For example: <pre><code>This will build the application in the specified mode (debug or release) and use the specified path to the Ivf2 framework. If no path is specified, it will use the default path which is `..\\ivf2`.\n\n## Configure and build the application (Linux)\n\nTo configure the application you need to run CMake with the following options:\n\n```bash\ncmake --preset linux\n</code></pre> To configure a debug build, use the following command:</p> <p><pre><code>cmake --preset linux-debug\n</code></pre> To build a release version of the application, use the following command:</p> <p><pre><code>cmake --build --preset release\n</code></pre> To build a debug version of the application, use the following command:</p> <pre><code>cmake --build --preset debug\n</code></pre>"},{"location":"ui/ui_windows/","title":"UI Windows","text":"<p>ivf2 provides a user interface system built on Dear ImGui.</p>"},{"location":"ui/ui_windows/#overview","title":"Overview","text":"<p>The UI window system in ivf2 allows you to create customizable user interface elements for controlling your application. UI windows are implemented using the Dear ImGui library, providing a lightweight and immediate-mode interface.</p>"},{"location":"ui/ui_windows/#creating-a-ui-window","title":"Creating a UI Window","text":"<p>To create a UI window, subclass the <code>ivfui::UiWindow</code> class:</p> <pre><code>class MyControlWindow : public ivfui::UiWindow {\nprivate:\n    float m_value;\n    bool m_toggle;\n\npublic:\n    MyControlWindow() : UiWindow(\"My Controls\"), m_value(0.0f), m_toggle(false) {}\n\n    static std::shared_ptr&lt;MyControlWindow&gt; create() {\n        return std::make_shared&lt;MyControlWindow&gt;();\n    }\n\n    void doDraw() override {\n        ImGui::Text(\"Control Panel\");\n        ImGui::SliderFloat(\"Value\", &amp;m_value, 0.0f, 1.0f);\n        ImGui::Checkbox(\"Toggle\", &amp;m_toggle);\n\n        if (ImGui::Button(\"Reset\")) {\n            m_value = 0.0f;\n            m_toggle = false;\n        }\n    }\n\n    float getValue() const { return m_value; }\n    bool getToggle() const { return m_toggle; }\n};\n</code></pre>"},{"location":"ui/ui_windows/#adding-ui-windows-to-a-scene","title":"Adding UI Windows to a Scene","text":"<p>To add a UI window to your scene:</p> <pre><code>class MyApplication : public ivfui::GLFWSceneWindow {\nprivate:\n    MyControlWindowPtr m_controlWindow;\n\npublic:\n    int onSetup() override {\n        // Create UI window\n        m_controlWindow = MyControlWindow::create();\n\n        // Add UI window to the scene\n        this-&gt;addUiWindow(m_controlWindow);\n\n        return 0;\n    }\n\n    void onUpdateUi() override {\n        // Use the UI values in your scene\n        if (m_controlWindow-&gt;getToggle()) {\n            // Do something based on toggle state\n        }\n\n        float value = m_controlWindow-&gt;getValue();\n        // Use the value\n    }\n};\n</code></pre>"},{"location":"ui/ui_windows/#ui-window-features","title":"UI Window Features","text":"<ul> <li>Show/Hide: Control window visibility with <code>show()</code> and <code>hide()</code> methods</li> <li>Window title: Set in the constructor</li> <li>State access: Create accessors to get/set internal state</li> <li>ImGui widgets: Use any ImGui widget in your <code>doDraw()</code> method</li> </ul>"}]}